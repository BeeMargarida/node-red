/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

module.exports = function (RED) {
    "use strict";

    const axios = require('axios');

    function OrchestratorNode(n) {
        RED.nodes.createNode(this, n);
        this.topic = n.topic;
        this.qos = n.qos || null;
        this.retain = n.retain;
        this.broker = n.broker;
        this.brokerConn = this.broker !== undefined ? RED.nodes.getNode(this.broker) : null;
        var node = this;
        var chk = /[\+#]/;

        this.nodeAssignment = {};
        this.devices = {};
        this.pingInterval = null;

        node.setupMQTT();

        this.setPredicates(["node-red"]);

        OrchestratorNode.prototype.receive = function (content) {
            const type = content.type;
            const msg = { payload: content.data };
            if (type === "assignment") {
                node.send(msg);
            }
            else {
                const device = content.device;

                if (this.brokerConn) {
                    this.status({ fill: "red", shape: "ring", text: "node-red:common.status.disconnected" });
                    if (msg.qos) {
                        msg.qos = parseInt(msg.qos);
                        if ((msg.qos !== 0) && (msg.qos !== 1) && (msg.qos !== 2)) {
                            msg.qos = null;
                        }
                    }
                    msg.qos = Number(node.qos || msg.qos || 0);
                    msg.retain = node.retain || msg.retain || false;
                    msg.retain = ((msg.retain === true) || (msg.retain === "true")) || false;
                    if (node.topic) {
                        const topicDevice = node.topic.replace("+", device);
                        msg.topic = topicDevice;
                    }
                    if (msg.hasOwnProperty("payload")) {
                        if (msg.hasOwnProperty("topic") && (typeof msg.topic === "string") && (msg.topic !== "")) { // topic must exist
                            if (chk.test(msg.topic)) { node.warn(RED._("orchestrator.errors.invalid-topic")); }
                            this.brokerConn.publish(msg, null);  // send the message
                        } else {
                            node.warn(RED._("orchestrator.errors.invalid-topic"));
                            done && done();
                        }
                    } else {
                        done && done();
                    }
                }
            }
        }

        this.on("input", function (msg, done) {
            try {
                const value = RED.util.getMessageProperty(msg, "payload");
                this.devices = value;
                const nodes = node._flow.activeNodes;
                distributeFlow(nodes, null);
            } catch (err) {
                done(JSON.stringify(err));
            }
        });

        if (this.brokerConn.connected) {
            node.status({ fill: "green", shape: "dot", text: "node-red:common.status.connected" });
        }

        node.brokerConn.register(node);
        this.on('close', function (done) {
            node.brokerConn.deregister(node, done);
        });

        /**
         * [MINE]
         * 
         * Generates a micropython script that contains all the 
         * functionality of the given nodes.
         * 
         * @param {*} nodes of a device
         */
        function generateCode(nodes) {
            let inputTopics = [];
            let outputTopics = [];
            let nodesId = nodes.map(n => `"${n.textId}"`);
            let nodesStr = nodes.map(n => `${n.type.replace(/ /g, '')}:${n.textId}`);

            // Code for each node mqtt topic
            for (let i = 0; i < nodes.length; i++) {
                inputTopics.push.apply(inputTopics, nodes[i].inputTopics);
                outputTopics.push.apply(outputTopics, nodes[i].outputTopics);
            }

            // Remove duplicates
            inputTopics = Array.from(new Set(inputTopics));
            outputTopics = Array.from(new Set(outputTopics));

            // Global variables
            let code = `import gc
import sys
import ujson
import uasyncio as asyncio
mqtt_client = None
nodes_str = "${nodesStr.join(" ")}"
nodes_id = [${nodesId}]
input_topics = [${inputTopics.map(a => `"${a}"`)}]
output_topics = [${outputTopics.map(a => `"${a}"`)}]\n`

            let onInputCode = `\r\ndef on_input(topic, msg, retained):\n    topic = topic.decode()\n`;
            let if_count = 0;
            for (let i = 0; i < nodes.length; i++) {
                // Node specific code
                code += nodes[i].micropythonCode;

                // Continue if node generates is own
                // input instead of receiving it
                if (!nodes[i].hasInput) continue;

                onInputCode += if_count === 0 ? `    if` : `    elif`;
                onInputCode += ` topic in input_topics_${nodes[i].textId}:\n`
                onInputCode += `        on_input_${nodes[i].textId}(topic, msg, retained)\n`

                if_count++;
            }


            // General code
            code += `${onInputCode}
async def conn_han(client):
    for input_topic in input_topics:
        await client.subscribe(input_topic, 1)

async def on_output(msg, output):
    for output_topic in output:
        await mqtt_client.publish(output_topic, msg, qos = 1)

def get_nodes():
    return nodes_str

def stop():
    for id in nodes_id:
        func_name = "stop_" + id
        if func_name in globals():
            getattr(sys.modules[__name__], func_name)()

async def exec(mqtt_c):
    global mqtt_client
    mqtt_client = mqtt_c
    for id in nodes_id:
        func_name = "exec_" + id
        if func_name in globals():
            getattr(sys.modules[__name__], func_name)()
    return\n`

            return code;
        }

        /**
         * [MINE]
         * 
         * Sends micropython scripts to the specified device
         * 
         * @param {*} code micropython script to be sent to the device
         * @param {*} device device to send the code
         */
        function sendCode(code, address, nrNodes) {
            const startTime = Date.now();
            return axios({
                method: 'POST',
                url: `http://${address}/execute`,
                data: code,
                headers: {
                    "Content-Type": "text/plain"
                }
            }).then(res => {
                console.log(res);
                // Send telemetry to orchestrator nodes
                this.receive({ type: "telemetry", device: address, data: { duration: Date.now() - startTime, state: 1 } });
                return { id: address, nodes: nrNodes, status: res.status };
            }).catch(err => {
                // Send telemetry to orchestrator nodes
                this.receive({ type: "telemetry", device: address, data: { duration: Date.now() - startTime, state: 0 } });
                return { id: address, nodes: nrNodes, status: err.response ? err.response.status : 500 }
            })
        }

        /**
         * [MINE]
         * 
         * Generates code and sends it to the respective device.
         * @param {*} devices available devices in the network
         */
        async function generateAndSend(nodeAssignment) {
            const promises = [];
            // For each device, generate and send code of the assigned nodes
            for (const id in nodeAssignment) {
                if (id === "node-red" || nodeAssignment[id].nodes.length === 0) continue;

                const code = generateCode(nodeAssignment[id].nodes);
                promises.push(sendCode(code, id, nodeAssignment[id].nodes.length));

                // @TODO: Remove later
                const fs = require('fs');
                fs.writeFile(`python-scripts/total-code-${id}.py`, code, function (err) {
                    if (err) {
                        return console.log(err);
                    }
                    console.log("The python script file was saved!");
                });
            };

            const changes = {};
            const values = await Promise.all(promises);
            for (const val of values) {
                // Checks if there was any memory problem or
                // others and saves it in changes
                if (val.status === 413) {
                    changes[val.id] = {
                        memoryErrorNodes: val.nodes
                    }
                }
                else if (val.status === 424) {
                    // Retry again if given this error, since
                    // it is connected to failure to connect
                    // to MQTT broker due to fast requests
                    changes[val.id] = {}
                } else if (val.status !== 200) {
                    changes[val.id] = {
                        status: 0,
                        nodes: []
                    }
                }
            }

            return changes;

        }

        /**
         * [MINE]
         * 
         * Returns the best device to run a specific node, based on their tags simalirities and available
         * resources in the devices.
         * 
         * @param {*} devices available devices in the network
         * @param {*} node node from the flow
         */
        function getBestDevice(devices, node, nodeAssignment) {
            const nodePredicates = node.predicates;
            const nodePriorities = node.priorities;

            let bestMatchIndex = 0;
            let bestDevice = null;

            for (const id in devices) {
                const device = devices[id];

                if (device.status !== 1 || (nodeAssignment[id] && nodeAssignment[id].status !== 1)) continue;

                // Keep the node assigned if node was already previously assigned to the it
                if (nodeAssignment[id] && nodeAssignment[id].nodes.filter(n => n.id === node.id).length > 0 && !device.memoryErrorNodes) return id;

                // Ignores if the number of nodes assigned to the device with a new one is
                // equal or greater than a previous assignment that resulted in memory error
                if (nodeAssignment[id] && nodeAssignment[id].nodes.filter(n => n.id === node.id).length > 0 &&
                    (nodeAssignment[id].nodes.length + 1) >= device.memoryErrorNodes) continue;

                // Specific case, if there is already one temperature-humidity sensor
                // assigned, don't assign another to this device
                // if (node.type === "temperature-humidity" && nodeAssignment[id] &&
                //     nodeAssignment[id].nodes.filter(n => n.type === "temperature-humidity").length > 0) continue;

                // Filter device capabilities to check if the device complies with the 
                // node predicates, which are requirements that cannot be violated
                const predicateIntersection = nodePredicates.filter(tag => device.capabilities.includes(tag));

                // Ignores if there is no intersection or the intersection
                // does not contain all the tags from the node. Node-red is the default
                if (predicateIntersection.length < nodePredicates.length) continue;

                // Filter device capabilities to check if the device has any priority
                // requested by the node, which makes the device more attractive for assignment
                const prioritiesIntersection = nodePriorities.filter(tag => device.capabilities.includes(tag));
                const prioritiesIndex = prioritiesIntersection.length === 0 ? 0 : (prioritiesIntersection.length / nodePriorities.length);

                // Nodes with less nodes assigned, more priorities complied and 
                // more specific intersections have a better match index
                const nrNodes = nodeAssignment[id] ? nodeAssignment[id].nodes.length : 0;
                const matchIndex = prioritiesIndex * 0.5 +
                    (1 / (nrNodes + 1)) * 0.4 +
                    (predicateIntersection.length / device.capabilities.length) * 0.1;

                if (matchIndex > bestMatchIndex) {
                    bestMatchIndex = matchIndex;
                    bestDevice = id;
                }
            }

            return bestDevice;
        }

        /**
         * [MINE]
         * 
         * Distributes the nodes of the flow among the available devices, in an efficient way. 
         * If there was changes in the devices, the distribution is remade in order to maximize 
         * efficiency and the operability of the flow.
         * 
         * @param {*} nodes nodes of the flow
         * @param {*} changes changes in the devices
         */
        async function distributeFlow(nodes, changes) {
            if (Object.keys(nodes).length === 0) return {};
            this.assigning = true;

            console.log("[MINE] Flow distribution - Nodes:", nodes, changes);

            // Clean previous assignments in the devices
            for (const id in this.devices) {
                this.devices[id].nodes = [];
            }

            const nodeAssignment = this.nodeAssignment;

            if (changes && nodeAssignment) {
                // Merge devices with changes, so that the devices information is updated
                for (const id in nodeAssignment) {
                    const changedDevice = changes[id];
                    if (changedDevice) {
                        nodeAssignment[id] = { ...nodeAssignment[id], ...changedDevice };
                    }
                }
            }

            // Assign each node to a device matching the tags
            Object.entries(nodes).forEach(([k, node], index) => {
                if (node.type === "mqtt-broker" || node.type === "tab") return;
                if (!node.type.includes("orchestrator") &&
                    (node.type.includes("subflow") || (node.inputTopics.length === 0 && node.outputTopics.length === 0))) return;

                node._flow.activeNodes[node.id] = node;

                // Generate node's micropython code 
                node.generateCode();

                const deviceId = getBestDevice(this.devices, node, nodeAssignment);

                if (deviceId) {
                    node.setDevice(this.devices[deviceId]);

                    // Save this configuration in the current configuration object
                    if (nodeAssignment[deviceId] && nodeAssignment[deviceId].nodes.filter(n => n.id === node.id).length === 0) {
                        nodeAssignment[deviceId].nodes.push(node.info());
                    } else {
                        nodeAssignment[deviceId] = {
                            status: 1,
                            nodes: [node.info()]
                        }
                    }
                }
                else {
                    // If there is no possibility to comply with the predicate of the node
                    // an error should be thrown since the assignment is not possible
                    if (node.predicates.length > 0 && !node.predicates.includes("node-red")) {
                        this.error(`Predicates in node ${node.id} cannot be satisfied.`);
                        // throw new Error(`Predicates in node ${node.type} ${node.id} cannot be satisfied.`);
                    }

                    // Setup local MQTT because the node will be executed locally
                    if (nodeAssignment["node-red"] && nodeAssignment["node-red"].nodes.filter(n => n.id === node.id).length === 0) {
                        nodeAssignment["node-red"].nodes.push(node.info());
                    } else {
                        nodeAssignment["node-red"] = {
                            status: 1,
                            nodes: [node.info()]
                        }
                    }
                    node.setupMQTT();
                }
            });

            // Remove previous assignment to devices that are not active
            for (const id in nodeAssignment) {
                if (nodeAssignment[id].status === 0 && nodeAssignment[id].nodes.length > 0) {
                    nodeAssignment[id].nodes = [];
                }
            }
            // Save current assignment in the flow context
            this.nodeAssignment = { ...nodeAssignment };

            const assignmentResult = await generateAndSend(nodeAssignment);

            // If there were results in the assignment result,
            // meaning not functional devices or memory errors,
            // the distribution must be remade
            if (Object.keys(assignmentResult).length > 0) {
                this.assigning = false;
                distributeFlow(nodes, assignmentResult);
                return {};
            }

            if (Object.keys(nodeAssignment).length > 0) {
                const fs = require('fs');
                fs.writeFile(`python-scripts/node-assignment-${Date.now()}.json`,
                    JSON.stringify(nodeAssignment),
                    function (err) {
                        if (err) {
                            return {};
                        }
                        console.log("The node assignmet file was saved!");
                    });

                // Send assignment to orchestrator nodes
                for (const id in node._flow.activeNodes) {
                    if (node._flow.activeNodes[id].type === "orchestrator") {
                        node._flow.activeNodes[id].receive({ type: "assignment", data: nodeAssignment });
                    }
                }
            }

            this.assigning = false;
            return nodeAssignment;
        }

        /**
         * [MINE]
         * 
         * Checks all devices for their state and availability. 
         * If changes to the devices are detected, the distribution
         * of computation must be remade.
         * 
         */
        async function ping() {
            if (this.assigning) return;

            const changes = {};
            const promises = [];
            const devices = this.devices;

            for (const id in devices) {
                // Request timeout logic if the device
                // goes down and becomes unreachable
                let source = axios.CancelToken.source();
                setTimeout(() => {
                    source.cancel();
                }, 2000);

                const promise = axios({
                    method: 'GET',
                    url: `http://${id}/ping`,
                    cancelToken: source.token
                }).then(res => {
                    console.log(`DEVICE ${id} STATUS: ` + res.data.status);
                    if (devices[id].status !== 1) {
                        this.devices[id].status = 1;
                        changes[id] = { status: 1 }
                    }
                }).catch(err => {
                    console.log(`DEVICE ${id} ERROR: ` + err);
                    if (devices[id].status !== 0) {
                        this.devices[id].status = 0;
                        changes[id] = { status: 0, nodes: [] }
                    }
                });
                promises.push(promise);
            }

            await Promise.all(promises);

            if (Object.keys(changes).length > 0) {
                distributeFlow(node._flow.activeNodes, changes)
            }
        }

        /**
         * [MINE]
         * 
         * Sets up an interval for the ping pattern.
         * 
         */
        function setupPing() {
            // Only one ping is running
            if (this.pingInterval !== undefined) return this.pingInterval;
            this.pingInterval = setInterval(() => ping(), 10000)
            return this.pingInterval;
        }

    }
    RED.nodes.registerType("orchestrator", OrchestratorNode);
};
