/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

module.exports = function (RED) {
    "use strict";

    var operators = {
        'eq': function (a, b) { return a == b; },
        'neq': function (a, b) { return a != b; },
        'lt': function (a, b) { return a < b; },
        'lte': function (a, b) { return a <= b; },
        'gt': function (a, b) { return a > b; },
        'gte': function (a, b) { return a >= b; },
        'btwn': function (a, b, c) { return (a >= b && a <= c) || (a <= b && a >= c); },
        'true': function (a) { return a === true; },
        'false': function (a) { return a === false; },
        'null': function (a) { return (typeof a == "undefined" || a === null); },
        'nnull': function (a) { return (typeof a != "undefined" && a !== null); }
    };

    let pythonOperators = {
        'eq': "a == b",
        'neq': "a != b",
        'lt': "a < b",
        'lte': "a <= b",
        'gt': "a > b",
        'gte': "a >= b",
        'btwn': "(a >= b and a <= c)  or (a <= b and a >= c)",
        'true': "a == True",
        'false': "a == False",
        'null': "a == None",
        'nnull': "a != None"
    }

    var _maxKeptCount;

    function getMaxKeptCount() {
        if (_maxKeptCount === undefined) {
            var name = "nodeMessageBufferMaxLength";
            if (RED.settings.hasOwnProperty(name)) {
                _maxKeptCount = RED.settings[name];
            }
            else {
                _maxKeptCount = 0;
            }
        }
        return _maxKeptCount;
    }

    function getProperty(node, msg, done) {
        if (node.propertyType === 'jsonata') {
            RED.util.evaluateJSONataExpression(node.property, msg, (err, value) => {
                if (err) {
                    done(RED._("if.errors.invalid-expr", { error: err.message }));
                } else {
                    done(undefined, value);
                }
            });
        } else {
            RED.util.evaluateNodeProperty(node.property, node.propertyType, node, msg, (err, value) => {
                if (err) {
                    done(undefined, undefined);
                } else {
                    done(undefined, value);
                }
            });
        }
    }

    function getV1(node, msg, rule, hasParts, done) {
        if (rule.vt === 'prev') {
            return done(undefined, node.previousValue);
        } else if (rule.vt === 'jsonata') {
            var exp = rule.v;
            if (rule.t === 'jsonata_exp') {
                if (hasParts) {
                    exp.assign("I", msg.parts.index);
                    exp.assign("N", msg.parts.count);
                }
            }
            RED.util.evaluateJSONataExpression(exp, msg, (err, value) => {
                if (err) {
                    done(RED._("if.errors.invalid-expr", { error: err.message }));
                } else {
                    done(undefined, value);
                }
            });
        } else if (rule.vt === 'json') {
            done(undefined, "json"); // TODO: ?! invalid case
        } else if (rule.vt === 'null') {
            done(undefined, "null");
        } else {
            RED.util.evaluateNodeProperty(rule.v, rule.vt, node, msg, function (err, value) {
                if (err) {
                    done(undefined, undefined);
                } else {
                    done(undefined, value);
                }
            });
        }
    }

    function getV2(node, msg, rule, done) {
        var v2 = rule.v2;
        if (rule.v2t === 'prev') {
            return done(undefined, node.previousValue);
        } else if (rule.v2t === 'jsonata') {
            RED.util.evaluateJSONataExpression(rule.v2, msg, (err, value) => {
                if (err) {
                    done(RED._("if.errors.invalid-expr", { error: err.message }));
                } else {
                    done(undefined, value);
                }
            });
        } else if (typeof v2 !== 'undefined') {
            RED.util.evaluateNodeProperty(rule.v2, rule.v2t, node, msg, function (err, value) {
                if (err) {
                    done(undefined, undefined);
                } else {
                    done(undefined, value);
                }
            });
        } else {
            done(undefined, v2);
        }
    }

    function applyRule(node, msg, property, state, done) {
        var rule = node.rules[state.currentRule];
        var v1, v2;

        getV1(node, msg, rule, state.hasParts, (err, value) => {
            if (err) {
                return done(err);
            }
            v1 = value;
            getV2(node, msg, rule, (err, value) => {
                if (err) {
                    return done(err);
                }
                v2 = value;

                const result = operators[rule.t](property, v1, v2, rule.case, msg.parts);

                if (result) {
                    state.onward.push(msg);
                    state.elseflag = false;
                } else {
                    state.onward.push(null);
                }
                done(undefined, state.currentRule < node.rules.length - 1, result);
            });
        });
    }

    function applyRules(node, msg, property, state, result, done) {
        if (!state) {
            state = {
                currentRule: 0,
                elseflag: true,
                onward: [],
                hasParts: msg.hasOwnProperty("parts") &&
                    msg.parts.hasOwnProperty("id") &&
                    msg.parts.hasOwnProperty("index")
            }
        }
        applyRule(node, msg, property, state, (err, hasMore, newResult) => {
            if (err) {
                return done(err);
            }
            if (hasMore) {
                state.currentRule++;
                applyRules(node, msg, property, state, newResult && result, done);
            } else {
                node.previousValue = property;
                done(undefined, state.onward, result && newResult);
            }
        });
    }


    function IfNode(n) {
        RED.nodes.createNode(this, n);
        this.rules = n.rules || [];
        this.property = n.property;
        this.propertyType = n.propertyType || "msg";

        if (this.propertyType === 'jsonata') {
            try {
                this.property = RED.util.prepareJSONataExpression(this.property, this);
            } catch (err) {
                this.error(RED._("if.errors.invalid-expr", { error: err.message }));
                return;
            }
        }

        this.checkall = n.checkall || "true";
        this.previousValue = null;
        var node = this;
        var valid = true;
        var repair = n.repair;
        var needsCount = repair;

        for (var i = 0; i < this.rules.length; i += 1) {
            var rule = this.rules[i];
            needsCount = needsCount;
            if (!rule.vt) {
                if (!isNaN(Number(rule.v))) {
                    rule.vt = 'num';
                } else {
                    rule.vt = 'str';
                }
            }

            if (rule.vt === 'num') {
                if (!isNaN(Number(rule.v))) {
                    rule.v = Number(rule.v);
                }
            }
        }

        if (typeof rule.v2 !== 'undefined') {
            if (!rule.v2t) {
                if (!isNaN(Number(rule.v2))) {
                    rule.v2t = 'num';
                } else {
                    rule.v2t = 'str';
                }
            }
            if (rule.v2t === 'num') {
                rule.v2 = Number(rule.v2);
            }
        }
        if (!valid) {
            return;
        }

        var pendingCount = 0;
        var pendingId = 0;
        var pendingIn = {};

        function addMessageToGroup(id, msg, parts) {
            if (!(id in pendingIn)) {
                pendingIn[id] = {
                    count: undefined,
                    msgs: [],
                    seq_no: pendingId++
                };
            }
            var group = pendingIn[id];
            group.msgs.push(msg);
            pendingCount++;
            var max_msgs = getMaxKeptCount();
            if ((max_msgs > 0) && (pendingCount > max_msgs)) {
                clearPending();
                node.error(RED._("if.errors.too-many"), msg);
            }
            if (parts.hasOwnProperty("count")) {
                group.count = parts.count;
            }
            return group;
        }

        function drainMessageGroup(msgs, count, done) {
            var msg = msgs.shift();
            msg.parts.count = count;
            processMessage(msg, false, err => {
                if (err) {
                    done(err);
                } else {
                    if (msgs.length === 0) {
                        done()
                    } else {
                        drainMessageGroup(msgs, count, done);
                    }
                }
            })
        }
        function addMessageToPending(msg, done) {
            var parts = msg.parts;
            // We've already checked the msg.parts has the require bits
            var group = addMessageToGroup(parts.id, msg, parts);
            var msgs = group.msgs;
            var count = group.count;
            var msgsCount = msgs.length;
            if (count === msgsCount) {
                // We have a complete group - send the individual parts
                drainMessageGroup(msgs, count, err => {
                    pendingCount -= msgsCount;
                    delete pendingIn[parts.id];
                    done();
                })
                return;
            }
            done();
        }

        function processMessage(msg, checkParts, done) {
            var hasParts = msg.hasOwnProperty("parts") &&
                msg.parts.hasOwnProperty("id") &&
                msg.parts.hasOwnProperty("index");

            if (needsCount && checkParts && hasParts) {
                addMessageToPending(msg, done);
            } else {
                getProperty(node, msg, (err, property) => {
                    if (err) {
                        node.warn(err);
                        done();
                    } else {
                        applyRules(node, msg, property, undefined, true, (err, onward, result) => {
                            if (err) {
                                node.warn(err);
                            } else {
                                const newMsg = { ...msg, payload: result };
                                node.send(newMsg);
                            }
                            done();
                        });
                    }
                });
            }
        }

        function clearPending() {
            pendingCount = 0;
            pendingId = 0;
            pendingIn = {};
        }

        var pendingMessages = [];
        var handlingMessage = false;
        var processMessageQueue = function (msg) {
            if (msg) {

                // A new message has arrived - add it to the message queue
                pendingMessages.push(msg);
                if (handlingMessage) {
                    // The node is currently processing a message, so do nothing
                    // more with this message
                    return;
                }
            }
            if (pendingMessages.length === 0) {
                // There are no more messages to process, clear the active flag
                // and return
                handlingMessage = false;
                return;
            }

            // There are more messages to process. Get the next message and
            // start processing it. Recurse back in to check for any more
            var nextMsg = pendingMessages.shift();
            handlingMessage = true;
            processMessage(nextMsg, true, err => {
                if (err) {
                    node.error(err, nextMsg);
                }
                processMessageQueue()
            });
        }

        this.on('input', function (msg) {
            processMessageQueue(msg);
        });

        this.on('close', function () {
            clearPending();
        });


        // MICROPYTHON CODE
        this.micropythonCode = generateMicropythonCode(this.rules);
        console.log(this.micropythonCode);

        function pythonParameters(values) {
            if (values.length === 0) return "";
            else if (values.length === 1) return `, b = ${values[0]}`;
            else return `, b = ${values[0]}, c = ${values[1]}`;
        }

        /**
         * [MINE]
         * 
         * Generates micropython code that exxecutes the switch behaviour
         * 
         * @param {*} rules 
         */
        function generateMicropythonCode(rules) {
            let code = "";
            console.log("MICROPYTHON CODE GENERATION");

            let switchBlock = ``;
            let rulesBlock = ``;

            for (let i = 0; i < rules.length; i++) {

                let valuesRule = Object.keys(rules[i]).filter(k => {
                    return k.indexOf('v') === 0 && k.indexOf('t') === -1
                }).map((k) => (rules[i][k]));

                const switchRules = `
                    def switchRule${i}(a${pythonParameters(valuesRule)}):
                        return ${pythonOperators[rules[i].t]}
                `;

                rulesBlock += i == 0 ? `switchRule${i}(a)` : ` && switchRule${i}(a)`;
                switchBlock += switchRules;
            }


            switchBlock += `
                def switch(a):
                    return ${rulesBlock}
            `;

            code = `
                mqtt_client = None
                input_topic = ${node.inputTopics[0]}
                output_topics = ${node.outputTopics}
                done = False

                ${switchBlock}

                def on_input(topic, msg):
                    global done
                    res = switch(msg)
                    on_output(res)
                    done = True

                def on_output(msg):
                    for output_topic in output_topics:
                        mqtt_client.publish(output_topic, '%s' % msg)

                def exec(mqtt_c):
                    global mqtt_client
                    mqtt_client = mqtt_c
                    mqtt_client.set_callback(on_input)
                    mqtt_client.subscribe(input_topic)
                    while done == False:
                        mqtt_client.check_msg()
                    return
            `

            return code;
        }
    }

    RED.nodes.registerType("if", IfNode);
}
