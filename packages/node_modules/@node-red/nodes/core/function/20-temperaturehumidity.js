/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

module.exports = function (RED) {
    "use strict";

    function TemperatureHumidityNode(n) {
        RED.nodes.createNode(this, n);
        const node = this;
        this.name = n.name;
        this.pin = parseInt(n.pin);
        this.repeat = Boolean(n.repeat);
        this.interval = parseFloat(n.interval)
        this.micropythonCode = n.micropythonCode || "";
        
        this.tags = n.tags.length === 0 ? [] : n.tags.split(" "); 
        this.setPredicates(this.tags);
        this.setInput(false);
        
        this.setGenerateCodeFunction(() => generateMicropythonCode(this.pin, this.repeat, this.interval));
        
        // @TODO: Make behaviour for javascript ?
        
        this.on("close", function () {
            this.status({});
        });


        /**
         * [MINE]
         * 
         * Generates micropython code that exxecutes the switch behaviour
         * 
         * @param {*} rules 
         */
        function generateMicropythonCode(pin, repeat, interval) {
            const code =
                `\nimport dht
import machine
import sys
output_topics_${node.textId} = [${node.outputTopics.map(a => `"${a}"`)}]
pin_${node.textId} = ${pin}
interval_${node.textId} = ${interval}
repeat_${node.textId} = ${repeat === false ? "False" : "True"}
stop_repeat_${node.textId} = False

reference_timer_workaround = []

def measure_${node.textId}(_):
    pin = None
    if sys.platform != "linux":
        pin = machine.Pin(pin_${node.textId})
    d = dht.DHT22(pin)
    d.measure()
    temperature = d.temperature()
    humidity = d.humidity()
    results = dict(
        payload=dict(
            temperature=temperature,
            humidity=humidity
        ) 
    )
    loop = asyncio.get_event_loop()
    loop.create_task(on_output(ujson.dumps(results), output_topics_${node.textId}))

def stop_${node.textId}():
    global stop_repeat_${node.textId}
    stop_repeat_${node.textId} = True
    for timer in reference_timer_workaround:
        timer.deinit()

async def timer_exec_${node.textId}(callback, interval):
    if stop_repeat_${node.textId}:
        return
    callback(None)
    await asyncio.sleep_ms(interval)
    loop = asyncio.get_event_loop()
    loop.create_task(timer_exec_${node.textId}(callback, interval))

def exec_${node.textId}():
    if repeat_${node.textId}:
        if sys.platform != "linux":
            timer = machine.Timer(-1)    
            timer.init(period=interval_${node.textId}, mode=machine.Timer.PERIODIC, callback=measure_${node.textId})
            reference_timer_workaround.append(timer)
        else:
            loop = asyncio.get_event_loop()
            loop.create_task(timer_exec_${node.textId}(measure_${node.textId}, interval_${node.textId}))
    else: 
        measure_${node.textId}(None)
    return\n`

            node.setMicropythonCode(code);
        }

    }
    RED.nodes.registerType("temperature-humidity", TemperatureHumidityNode);
};
