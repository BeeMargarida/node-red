/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

module.exports = function (RED) {
    "use strict";

    function AndNode(n) {
        RED.nodes.createNode(this, n);
        const node = this;
        this.name = n.name;
        this.count = parseInt(n.count);
        this.micropythonCode = n.micropythonCode || "";

        this.topics = []
        this.inputs = [];

        this.on("input", function (msg, done) {
            try {

                if (msg.hasOwnProperty("topic") && this.topics.indexOf(msg.topic) === -1) {
                    this.inputs.push(msg.payload);
                    this.topics.push(msg.topic);
                }

                if (this.topics.length === this.count) {
                    let result = true;
                    for (let i = 0; i < this.inputs.length; i++) {
                        result = result && this.inputs[i];
                    }

                    const msg = { payload: result };
                    node.send(msg);

                    this.topics = [];
                    this.inputs = [];
                }
            } catch (err) {
                done(JSON.stringify(err));
            }
        });
        this.on("close", function () {
            this.status({});
        });

        generateMicropythonCode(this.count);

        // const fs = require('fs');
        // fs.writeFile(`python-scripts/11-and-${node.id}.py`, node.micropythonCode, function (err) {
        //     if (err) {
        //         return console.log(err);
        //     }
        //     console.log("The file was saved!");
        // });

        /**
         * [MINE]
         * 
         * Generates micropython code that exxecutes the switch behaviour
         * 
         * @param {*} rules 
         */
        function generateMicropythonCode(count) {
            console.log("MICROPYTHON CODE GENERATION");

            const code =
                `import uasyncio as asyncio
mqtt_client = None
input_topics = [${node.inputTopics.map(a => `"${a}"`)}]
output_topics = [${node.outputTopics.map(a => `"${a}"`)}]
nr_inputs = ${count}
inputs = []
topics = []

def on_input(topic, msg, retained):
    global inputs
    glboal topics

    if not topic in topics:
        topics.append(topic)
        if (msg == b'True') or (msg == b'true'):
            inputs.append(True)
        elif (msg == b'False') or (msg == b'false'):
            inputs.append(False)
    
    if len(topics) == nr_inputs:
        result = True
        
        for entry in inputs:
            result = result and entry
        
        loop = asyncio.get_event_loop()
        loop.create_task(on_output(result))
        inputs = []
        topics = []
    
    return

async def conn_han(client):
    for input_topic in input_topics:
        await client.subscribe(input_topic, 1)

async def on_output(msg):
    for output_topic in output_topics:
        await mqtt_client.publish(output_topic, msg, qos = 1)

def exec(mqtt_c):
    global mqtt_client
    mqtt_client = mqtt_c
    return`

            node.setMicropythonCode(code);
        }

    }
    RED.nodes.registerType("and", AndNode);
};
