/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

module.exports = function (RED) {
    "use strict";
    var util = require("util");
    var vm = require("vm");

    function sendResults(node, send, _msgid, msgs, cloneFirstMessage) {
        if (msgs == null) {
            return;
        } else if (!util.isArray(msgs)) {
            msgs = [msgs];
        }
        var msgCount = 0;
        for (var m = 0; m < msgs.length; m++) {
            if (msgs[m]) {
                if (!util.isArray(msgs[m])) {
                    msgs[m] = [msgs[m]];
                }
                for (var n = 0; n < msgs[m].length; n++) {
                    var msg = msgs[m][n];
                    if (msg !== null && msg !== undefined) {
                        if (typeof msg === 'object' && !Buffer.isBuffer(msg) && !util.isArray(msg)) {
                            if (msgCount === 0 && cloneFirstMessage !== false) {
                                msgs[m][n] = RED.util.cloneMessage(msgs[m][n]);
                                msg = msgs[m][n];
                            }
                            msg._msgid = _msgid;
                            msgCount++;
                        } else {
                            var type = typeof msg;
                            if (type === 'object') {
                                type = Buffer.isBuffer(msg) ? 'Buffer' : (util.isArray(msg) ? 'Array' : 'Date');
                            }
                            node.error(RED._("function.error.non-message-returned", { type: type }));
                        }
                    }
                }
            }
        }
        if (msgCount > 0) {
            send(msgs);
        }
    }

    function AndNode(n) {
        RED.nodes.createNode(this, n);
        var node = this;
        this.name = n.name;

        var handleNodeDoneCall = true;

        this.on("input", function (msg, send, done) {
            try {
                var start = process.hrtime();
                context.msg = msg;
                context.send = send;
                context.done = done;

                this.script.runInContext(context);
                sendResults(this, send, msg._msgid, context.results, false);
                if (handleNodeDoneCall) {
                    done();
                }

                var duration = process.hrtime(start);
                var converted = Math.floor((duration[0] * 1e9 + duration[1]) / 10000) / 100;
                this.metric("duration", msg, converted);
                if (process.env.NODE_RED_FUNCTION_TIME) {
                    this.status({ fill: "yellow", shape: "dot", text: "" + converted });
                }
            } catch (err) {
                if ((typeof err === "object") && err.hasOwnProperty("stack")) {
                    //remove unwanted part
                    var index = err.stack.search(/\n\s*at ContextifyScript.Script.runInContext/);
                    err.stack = err.stack.slice(0, index).split('\n').slice(0, -1).join('\n');
                    var stack = err.stack.split(/\r?\n/);

                    //store the error in msg to be used in flows
                    msg.error = err;

                    var line = 0;
                    var errorMessage;
                    if (stack.length > 0) {
                        while (line < stack.length && stack[line].indexOf("ReferenceError") !== 0) {
                            line++;
                        }

                        if (line < stack.length) {
                            errorMessage = stack[line];
                            var m = /:(\d+):(\d+)$/.exec(stack[line + 1]);
                            if (m) {
                                var lineno = Number(m[1]) - 1;
                                var cha = m[2];
                                errorMessage += " (line " + lineno + ", col " + cha + ")";
                            }
                        }
                    }
                    if (!errorMessage) {
                        errorMessage = err.toString();
                    }
                    done(errorMessage);
                }
                else if (typeof err === "string") {
                    done(err);
                }
                else {
                    done(JSON.stringify(err));
                }
            }
        });
        this.on("close", function () {
            while (node.outstandingTimers.length > 0) {
                clearTimeout(node.outstandingTimers.pop());
            }
            while (node.outstandingIntervals.length > 0) {
                clearInterval(node.outstandingIntervals.pop());
            }
            this.status({});
        });

    }
    RED.nodes.registerType("and", AndNode);
};
