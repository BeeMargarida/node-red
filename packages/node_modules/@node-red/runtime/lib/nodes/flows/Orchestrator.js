const axios = require('axios');
const devices = require("../config/devices");

var Log;

class Orchestrator {
    constructor(context) {
        this.context = context;
        this.context.nodeAssignment = context.nodeAssignment ? context.nodeAssignment : {};
        this.context.nodes = {};
        this.context.devices = devices;
    }

    /**
     * Log an error-level message from this flow
     * @param  {[type]} msg [description]
     * @return {[type]}     [description]
     */
    error(msg) {
        Log.log({
            id: this.id || "global",
            level: Log.ERROR,
            type: this.TYPE,
            msg: msg
        })
    }

    /**
     * [MINE]
     * 
     * Generates a micropython script that contains all the 
     * functionality of the given nodes.
     * 
     * @param {*} nodes of a device
     */
    generateCode(nodes) {
        let inputTopics = [];
        let outputTopics = [];
        let nodesId = nodes.map(n => `"${n.textId}"`);

        // Code for each node mqtt topic
        for (let i = 0; i < nodes.length; i++) {
            inputTopics.push.apply(inputTopics, nodes[i].inputTopics);
            outputTopics.push.apply(outputTopics, nodes[i].outputTopics);
        }

        // Remove duplicates
        inputTopics = Array.from(new Set(inputTopics));
        outputTopics = Array.from(new Set(outputTopics));

        // Global variables
        let code = `import gc
import sys
import ujson
import uasyncio as asyncio
mqtt_client = None
nodes_id = [${nodesId}]
input_topics = [${inputTopics.map(a => `"${a}"`)}]
output_topics = [${outputTopics.map(a => `"${a}"`)}]\n`

        let onInputCode = `\r\ndef on_input(topic, msg, retained):\n    topic = topic.decode()\n`;
        let if_count = 0;
        for (let i = 0; i < nodes.length; i++) {
            // Node specific code
            code += nodes[i].micropythonCode;

            // Continue if node generates is own
            // input instead of receiving it
            if (!nodes[i].hasInput) continue;

            onInputCode += if_count === 0 ? `    if` : `    elif`;
            onInputCode += ` topic in input_topics_${nodes[i].textId}:\n`
            onInputCode += `        on_input_${nodes[i].textId}(topic, msg, retained)\n`

            if_count++;
        }


        // General code
        code += `${onInputCode}
async def conn_han(client):
    for input_topic in input_topics:
        await client.subscribe(input_topic, 1)

async def on_output(msg, output):
    for output_topic in output:
        await mqtt_client.publish(output_topic, msg, qos = 1)

def stop():
    for id in nodes_id:
        func_name = "stop_" + id
        if func_name in globals():
            getattr(sys.modules[__name__], func_name)()

async def exec(mqtt_c):
    global mqtt_client
    mqtt_client = mqtt_c
    for id in nodes_id:
        func_name = "exec_" + id
        if func_name in globals():
            getattr(sys.modules[__name__], func_name)()
    return\n`

        return code;
    }

    /**
     * [MINE]
     * 
     * Sends micropython scripts to the specified device
     * 
     * @param {*} code micropython script to be sent to the device
     * @param {*} device device to send the code
     */
    sendCode(code, address, nrNodes) {
        return axios({
            method: 'POST',
            url: `http://${address}/execute`,
            data: code,
            headers: {
                "Content-Type": "text/plain"
            }
        }).then(res => {
            console.log(res);
            return { id: address, nodes: nrNodes, status: res.status };
        }).catch(err => {
            return { id: address, nodes: nrNodes, status: err.response ? err.response.status : 500 }
        })
    }

    /**
     * [MINE]
     * 
     * Generates code and sends it to the respective device.
     * @param {*} devices available devices in the network
     */
    async generateAndSend(nodeAssignment) {
        const promises = [];
        // For each device, generate and send code of the assigned nodes
        for (const id in nodeAssignment) {
            if (id === "node-red" || nodeAssignment[id].nodes.length === 0) continue;

            const code = this.generateCode(nodeAssignment[id].nodes);
            promises.push(this.sendCode(code, id, nodeAssignment[id].nodes.length));

            // @TODO: Remove later
            const fs = require('fs');
            fs.writeFile(`python-scripts/total-code-${id}.py`, code, function (err) {
                if (err) {
                    return console.log(err);
                }
                console.log("The python script file was saved!");
            });
        };

        const changes = {};
        const values = await Promise.all(promises);
        for (const val of values) {
            // Checks if there was any memory problem or
            // others and saves it in changes
            if (val.status === 413) {
                changes[val.id] = {
                    memoryErrorNodes: val.nodes
                }
            }
            else if (val.status === 424) {
                // Retry again if given this error, since
                // it is connected to failure to connect
                // to MQTT broker due to fast requests
                changes[val.id] = {}
            } else if (val.status !== 200) {
                changes[val.id] = {
                    status: 0,
                    nodes: []
                }
            }
        }

        return changes;

    }

    /**
     * [MINE]
     * 
     * Returns the best device to run a specific node, based on their tags simalirities and available
     * resources in the devices.
     * 
     * @param {*} devices available devices in the network
     * @param {*} node node from the flow
     */
    getBestDevice(devices, node, nodeAssignment) {
        const nodePredicates = node.predicates;
        const nodePriorities = node.priorities;

        let bestMatchIndex = 0;
        let bestDevice = null;

        for (const id in devices) {
            const device = devices[id];

            if (device.status !== 1) continue;

            // Keep the node assigned if node was already previously assigned to the it
            if (nodeAssignment[id] && nodeAssignment[id].nodes.filter(n => n.id === node.id).length > 0 && !device.memoryErrorNodes) return id;

            // Ignores if the number of nodes assigned to the device with a new one is
            // equal or greater than a previous assignment that resulted in memory error
            if (nodeAssignment[id] && nodeAssignment[id].nodes.filter(n => n.id === node.id).length > 0 &&
                (nodeAssignment[id].nodes.length + 1) >= device.memoryErrorNodes) continue;

            // Specific case, if there is already one temperature-humidity sensor
            // assigned, don't assign another to this device
            if (node.type === "temperature-humidity" && nodeAssignment[id] &&
                nodeAssignment[id].nodes.filter(n => n.type === "temperature-humidity").length > 0) continue;

            // Filter device capabilities to check if the device complies with the 
            // node predicates, which are requirements that cannot be violated
            const predicateIntersection = nodePredicates.filter(tag => device.capabilities.includes(tag));

            // Ignores if there is no intersection or the intersection
            // does not contain all the tags from the node. Node-red is the default
            if (predicateIntersection.length < nodePredicates.length) continue;

            // Filter device capabilities to check if the device has any priority
            // requested by the node, which makes the device more attractive for assignment
            const prioritiesIntersection = nodePriorities.filter(tag => device.capabilities.includes(tag));
            const prioritiesIndex = prioritiesIntersection.length === 0 ? 0 : (prioritiesIntersection.length / nodePriorities.length);

            // Nodes with less nodes assigned, more priorities complied and 
            // more specific intersections have a better match index
            const matchIndex = prioritiesIndex * 0.5 +
                (1 / (device.nodes.length + 1)) * 0.4 +
                (predicateIntersection.length / device.capabilities.length) * 0.1;

            if (matchIndex > bestMatchIndex) {
                bestMatchIndex = matchIndex;
                bestDevice = id;
            }
        }

        return bestDevice;
    }

    /**
     * [MINE]
     * 
     * Distributes the nodes of the flow among the available devices, in an efficient way. 
     * If there was changes in the devices, the distribution is remade in order to maximize 
     * efficiency and the operability of the flow.
     * 
     * @param {*} nodes nodes of the flow
     * @param {*} changes changes in the devices
     */
    async distributeFlow(nodes, changes) {
        if (Object.keys(nodes).length === 0) return {};
        this.assigning = true;

        console.log("[MINE] Flow distribution - Nodes:", nodes, changes);

        // Clean previous assignments in the devices
        for (const id in this.context.devices) {
            this.context.devices[id].nodes = [];
        }

        const nodeAssignment = this.context.nodeAssignment;

        if (changes && nodeAssignment) {
            // Merge devices with changes, so that the devices information is updated
            for (const id in nodeAssignment) {
                const changedDevice = changes[id];
                if (changedDevice) {
                    nodeAssignment[id] = { ...nodeAssignment[id], ...changedDevice };
                }
            }
        }

        // Assign each node to a device matching the tags
        Object.entries(nodes).forEach(([k, node], index) => {
            if (node.type === "mqtt-broker" || node.type === "tab") return;
            if (node.type.includes("subflow") || (node.inputTopics.length === 0 && node.outputTopics.length === 0)) return;

            this.context.nodes[node.id] = node;

            // Generate node's micropython code 
            node.generateCode();

            const deviceId = this.getBestDevice(this.context.devices, node, this.context.nodeAssignment);

            if (deviceId) {
                node.setDevice(this.context.devices[deviceId]);

                // Save this configuration in the current configuration object
                if (nodeAssignment[deviceId] && nodeAssignment[deviceId].nodes.filter(n => n.id === node.id).length === 0) {
                    nodeAssignment[deviceId].nodes.push(node.info());
                } else {
                    nodeAssignment[deviceId] = {
                        status: 1,
                        nodes: [node.info()]
                    }
                }
            }
            else {
                // If there is no possibility to comply with the predicate of the node
                // an error should be thrown since the assignment is not possible
                if (node.predicates.length > 0 && !node.predicates.includes("node-red")) {
                    this.error(`Predicates in node ${node.id} cannot be satisfied.`);
                    throw new Error(`Predicates in node ${node.type} ${node.id} cannot be satisfied.`);
                }

                // Setup local MQTT because the node will be executed locally
                if (nodeAssignment["node-red"] && nodeAssignment["node-red"].nodes.filter(n => n.id === node.id).length === 0) {
                    nodeAssignment["node-red"].nodes.push(node.info());
                } else {
                    nodeAssignment["node-red"] = {
                        status: 1,
                        nodes: [node.info()]
                    }
                }
                node.setupMQTT();
            }
        });

        // Remove previous assignment to devices that are not active
        for (const id in nodeAssignment) {
            if (nodeAssignment[id].status === 0 && nodeAssignment[id].nodes.length > 0) {
                nodeAssignment[id].nodes = [];
            }
        }
        // Save current assignment in the flow context
        this.context.nodeAssignment = {...nodeAssignment};

        const assignmentResult = await this.generateAndSend(nodeAssignment);

        // If there were results in the assignment result,
        // meaning not functional devices or memory errors,
        // the distribution must be remade
        if (Object.keys(assignmentResult).length > 0) {
            this.assigning = false;
            this.distributeFlow(nodes, assignmentResult);
            return;
        }

        if (Object.keys(nodeAssignment).length > 0) {
            const fs = require('fs');
            fs.writeFile(`python-scripts/node-assignment-${Date.now()}.json`,
                JSON.stringify(nodeAssignment),
                function (err) {
                    if (err) {
                        return {};
                    }
                    console.log("The node assignmet file was saved!");
                });

            // Send assignment to orchestrator nodes
            for (const id in this.context.nodes) {
                if (this.context.nodes[id].type === "orchestrator") {
                    this.context.nodes[id].receive(nodeAssignment);
                }
            }
        }

        this.assigning = false;
        return nodeAssignment;
    }

    /**
     * [MINE]
     * 
     * Checks all devices for their state and availability. 
     * If changes to the devices are detected, the distribution
     * of computation must be remade.
     * 
     */
    async ping() {
        if (this.assigning) return;

        const changes = {};
        const promises = [];
        const devices = this.context.devices;

        for (const id in devices) {
            // Request timeout logic if the device
            // goes down and becomes unreachable
            let source = axios.CancelToken.source();
            setTimeout(() => {
                source.cancel();
            }, 2000);

            const promise = axios({
                method: 'GET',
                url: `http://${id}/ping`,
                cancelToken: source.token
            }).then(res => {
                console.log(`DEVICE ${id} STATUS: ` + res.data.status);
                if (devices[id].status !== 1) {
                    changes[id] = { status: 1 }
                }
            }).catch(err => {
                console.log(`DEVICE ${id} ERROR: ` + err);
                if (devices[id].status !== 0) {
                    changes[id] = { status: 0, nodes: [] }
                }
            });
            promises.push(promise);
        }

        await Promise.all(promises);

        if (Object.keys(changes).length > 0) {
            this.distributeFlow(this.context.nodes, changes)
        }
    }

    /**
     * [MINE]
     * 
     * Sets up an interval for the ping pattern.
     * 
     */
    setupPing() {
        // Only one ping is running
        if (this.context.pingInterval !== undefined) return this.context.pingInterval;
        this.context.pingInterval = setInterval(() => this.ping(), 10000)
        return this.context.pingInterval;
    }
}

module.exports = {
    init: function (runtime) {
        Log = runtime.log;
    },
    create: function (context) {
        return new Orchestrator(context);
    },
    Orchestrator: Orchestrator
}